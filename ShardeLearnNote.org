* Sharde 读书笔记
** 渲染流水线
*** 渲染流程：
    1. 应用阶段：（CPU）输出渲染图元，准备渲染内容输出渲染图元。
    2. 几何阶段：（GPU）输出屏幕空间的顶点信息，用于处理和我们要绘制的几何相关事情。
    3. 光栅化阶段：（GPU）渲染在屏幕上使用上；个阶段传过来的数据在屏幕上产生像素，并渲染最终的图像。
*** CPU和GPU之间的通讯
    渲染流水线的起点是CPU，即应用阶段。应用阶段大致可分为下面3个阶段：
    1) 把数据加载到显存中。硬盘>>内存>>显存(顶点的位置信息，法线方向，顶点颜色，纹理坐标)
    2) 设置渲染状态。这些状态定义了场景中的网格是怎样被渲染的（使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等）。
    3) 调用Draw Call 实际上，Draw Call就是一个命令，它的发起方是CPU，接收方是GPU。
       当给定了一个Draw Call时，GPU就会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素
*** GPU流水线
    1. 几何阶段和光栅化阶段可以分成若干更小的流水线阶段，这些流水线阶段由GPU来实现
    2. 顶点着色器:（Vertex Shader）是流水线的第一个阶段，它的输入来自于CPU。顶点着色器需要完成的工作主要有：坐标变换和逐顶点光照。
    3. 坐标变换:顾名思义，就是对顶点的坐标（即位置）进行某种变换。
    4. 裁剪: 一个图元和摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外。
    5. 屏幕映射: （Screen Mapping）的任务是把每个图元的x和y坐标转换到屏幕坐标系（Screen Coordinates）下.
    6. 三角形设置: 由这一步开始就进入了光栅化阶段（Triangle Setup）。这个阶段会计算光栅化一个三角网格所需的信息。。光栅化阶段有两个最重要的目标：计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色。
    7. 三角形遍历: 三角形遍历（Triangle Traversal）阶段将会检查每个像素是否被一个三角网格所覆盖。如果被覆盖的话，就会生成一个片元（fragment）。而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换（Scan Conversion）。
       这一步的输出就是得到一个片元序列。
    8. 片元着色器:片元着色器（Fragment Shader）是另一个非常重要的可编程着色器阶段。
    9. 逐片元操作:终于到了渲染流水线的最后一步。逐片元操作（Per-Fragment Operations）是OpenGL中的说法，在DirectX中，这一阶段被称为输出合并阶段（Output-Merger）。
    终于到了渲染流水线的最后一步。
    逐片元操作（Per-Fragment Operations）是OpenGL中的说法，在DirectX中，这一阶段被称为输出合并阶段（Output-Merger）。

*** 什么是OpenGL/DirectX 
    OpenGL和DirectX就是这些图像应用编程接口，这些接口用于渲染二维或三维图形。这些接口架起了上层应用程序和底层GPU的沟通桥梁
    
*** 什么是HLSL、GLSL、CG

*** 为什么Draw Call多了会影响帧率？
    在每次调用Draw Call之前，CPU需要向GPU发送很多内容，包括数据、状态和命令等。
    在这一阶段，CPU需要完成很多工作，例如检查渲染状态等。而一旦CPU完成了这些
    准备工作，GPU就可以开始本次的渲染。GPU的渲染能力是很强的，渲染200个还是
    2 000个三角网格通常没有什么区别，因此渲染速度往往快于CPU提交命令的速度。
    如果Draw Call的数量太多，CPU就会把大量时间花费在提交Draw Call上，
    造成CPU的过载。图2.20显示了这样一个例子。
    
*** 如何减少Draw Call？
    尽管减少Draw Call的方法有很多，但我们这里仅讨论使用批处理（Batching）的方法。
    我们讲过，提交大量很小的Draw Call会造成CPU的性能瓶颈，
    即CPU把时间都花费在准备Draw Call的工作上了。那么，一个很显然的优化想法就是把
    很多小的DrawCall合并成一个大的Draw Call，这就是批处理的思想。
    需要注意的是，由于我们需要在CPU的内存中合并网格，而合并的过程是需要消耗时间的。
    因此，批处理技术更加适合于那些静态的物体，例如不会移动的大地、石头等，
    对于这些静态物体我们只需要合并一次即可。当然，我们也可以对动态物体进行批处理。
    但是，由于这些物体是不断运动的，因此每一帧都需要重新进行合并然后再发送给GPU，
    这对空间和时间都会造成一定的影响。
    （1）避免使用大量很小的网格。当不可避免地需要使用很小的网格结构时，
    考虑是否可以合并它们。
    （2）避免使用过多的材质。尽量在不同的网格之间共用同一个材质。
    

*** 什么是shader
    1. GPU流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码是会在GPU上运行的
    （对于固定管线的渲染来说，着色器有时等同于一些特定的渲染设置）；
    2. 有一些特定类型的着色器，如顶点着色器、片元着色器等；
    3. 依靠着色器我们可以控制流水线中的渲染细节，例如用顶点着色器来进行顶点变换以及
    传递数据，用片元着色器来进行逐像素的渲染。
